# Conversation Summary

## Decisions

1. Transport preferences: allow multiple transport modes per plan; no “mixed” option.
2. Transport modes stored as `plans.transport_modes TEXT[] NULL`; may be empty to let AI decide.
3. No per-day or per-block transport overrides; AI decides per activity at generation time.
4. Do not store transport preferences at user profile level; attach only to plans.
5. Plans over 30 days must not be generated or stored; UI prevents and backend hard-blocks such requests.
6. Store original note as `plans.note_text` (TEXT); AI output stored only as structured rows (days/blocks/activities), no JSON.
7. Admin can only SELECT events; keep events minimal.
8. Events table minimal: `events(id, user_id, plan_id NULL, event_type enum, created_at)`; no JSONB context.
9. Keep `budget` as non-null enum; editable at plan level.
10. Use FK with ON DELETE CASCADE across `plans -> plan_days -> plan_blocks -> plan_activities`; no separate transport modes table.
11. Skip indexes on transport modes (array field) for MVP.
12. Activity-level transport time stored as `transport_minutes INTEGER NULL`; no mode stored per activity.
13. Use fixed `block_type` enum order: morning, afternoon, evening.
14. Enforce `order_index` uniqueness within block: `(block_id, order_index)`; resequencing handled at API level.
15. Enforce 10 plans per user in API layer; no DB trigger for MVP.
16. RLS: owner-only access for user tables; admin can SELECT events only.

## Matched Recommendations

1. Plans hierarchy normalization accepted: `plans`, `plan_days`, `plan_blocks`, `plan_activities` with cascading FKs.
2. Activity ordering accepted: `order_index` unique per `block_id`; resequencing via API.
3. Transport captured at plan level as array; no join table; AI chooses per activity; `transport_minutes` stored in activities.
4. Enum usage accepted: `comfort`, `budget`, `trip_type`, `block_type`, `event_type`; `transport_mode` implicit via array values.
5. Date constraints: block >30 days at API; DB `CHECK (date_end >= date_start)`.
6. Events minimal schema accepted; admin SELECT-only RLS policy.
7. Index strategy accepted: essential indexes only on listing/detail paths; skip transport-related indexing.
8. No JSONB storage for AI output; structured rows only.
9. RLS policies: owner-based CRUD; child tables access via parent `plans.owner_id`.
10. No migrations needed initially; greenfield schema.

## Database planning summary

### Main requirements for the database schema

- Use Supabase (Postgres) as DB and Auth source of truth; application-level `app_users` maps to `auth.users.id`.
- Support CRUD for travel plans generated by AI, with a normalized structure for days, blocks, and activities.
- Store the user's original free-text note (`plans.note_text`) and persist AI results as structured rows (no JSONB AI blob persisted).
- Transport preferences are multi-select at the plan level and may be empty to allow AI free choice; no user-level transport preferences.
- Enforce business rules in the API: no plans longer than 30 days; limit of 10 saved plans per user.
- Minimal event logging with an `events` table (no heavy context payloads) and admin read-only access.

### Key entities and their relationships

- `app_users` (uuid PK) — maps to Supabase `auth.users.id`; contains role and created_at.
- `user_preferences` (1:1) — stores onboarding fields (people_count, trip_type, age, country, comfort, budget).
- `plans` (uuid PK) — owner_id FK to `app_users`; fields: name, destination_text, date_start, date_end, budget (enum NOT NULL), note_text (TEXT), transport_modes (TEXT[] NULL), created_at.
- `plan_days` (uuid PK) — FK to `plans`; fields: day_index INT, date DATE; unique constraints `(plan_id, day_index)` and `(plan_id, date)`.
- `plan_blocks` (uuid PK) — FK to `plan_days`; field: block_type ENUM (`morning`, `afternoon`, `evening`); unique `(day_id, block_type)`.
- `plan_activities` (uuid PK) — FK to `plan_blocks`; fields: title TEXT, duration_minutes INT, transport_minutes INT NULL, order_index INT; unique `(block_id, order_index)`.
- `events` (uuid PK) — user_id FK to `app_users`, plan_id NULLABLE, event_type ENUM, created_at TIMESTAMPTZ.
- FKs use `ON DELETE CASCADE` from `plans` downwards to keep deletes simple and consistent.

### Important security and scalability concerns

- Row-Level Security (RLS): enable RLS and implement owner-only policies for `plans` and related child tables; enforce `owner_id = auth.uid()` checks; `events` can be restricted so users only see/insert their own events; admins have SELECT access only.
- Enums for categorical data improve integrity and reduce errors.
- Use `uuid` primary keys and `created_at TIMESTAMPTZ` for ordering and scale.
- Minimal indexing strategy for MVP: index `plans(owner_id, created_at)`, `plan_days(plan_id, day_index)`, `plan_blocks(day_id)`, `plan_activities(block_id, order_index)`; skip indexing `transport_modes` array.
- Enforce expensive or complex business rules in API layer (10-plan limit, ≤30 days) to keep DB schema simple and minimize triggers.

### Unresolved issues or clarifications needed

- Standardize the exact transport array values (`'car'`, `'walk'`, `'public'`) and the API validation rules for them.
- Decide max length or sanitization rules for `plan_activities.title` and other free-text fields.
- Confirm whether `events.event_type` should be implemented as a DB enum (recommended) or validated at application level for simpler migrations.

## Unresolved issues

- Confirm exact set and casing for `plans.transport_modes` array values and validation strategy at API layer.
- Decide whether `plan_activities.title` length limits or sanitization rules are needed.
- Confirm whether `events.event_type` should be strictly enforced via enum in DB or via check constraint for faster migrations.
